/**
 * OSHI (https://github.com/oshi/oshi)
 *
 * Copyright (c) 2010 - 2019 The OSHI Project Team:
 * https://github.com/oshi/oshi/graphs/contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
// This file was automatically generated by the OSHI API generator; do not edit!
package oshi.api.hardware.disk.internal;

import java.lang.Override;
import javax.annotation.processing.Generated;
import oshi.api.DetachedContainerException;
import oshi.api.hardware.disk.Disk;
import oshi.driver.ComponentDriver;

/**
 * A storage device
 */
@Generated("oshi.ApiGenerator")
public abstract class DiskContainer implements Disk {
  private transient ComponentDriver driver;

  public String name;

  public String model;

  public String serial;

  /**
   * The disk's total size in bytes
   */
  public Long size;

  public Long reads;

  public Long readBytes;

  public Long writes;

  public Long writeBytes;

  public Long queueLength;

  public Long transferTime;

  public String modelFamily;

  public String firmwareVersion;

  public Long rotationRate;

  public Long readErrorRate;

  public Long spinUpTime;

  public Long startStopCycles;

  public Long reallocatedSectors;

  public Long seekErrorRate;

  public Long powerOnTime;

  public Long spinRetries;

  public Long calibrationRetries;

  public Long powerCycles;

  public Long poweroffRetracts;

  public Long loadCycles;

  public Long temperature;

  public Long reallocatedEvents;

  public Long currentPendingSector;

  public Long offlineUncorrectable;

  public Long crcErrors;

  public Long multizoneErrorRate;

  @Override
  public String getName() {
    return name;
  }

  @Override
  public String getModel() {
    return model;
  }

  @Override
  public String getSerial() {
    return serial;
  }

  @Override
  public Long getSize() {
    return size;
  }

  @Override
  public Long querySize() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.SIZE);
    return size;
  }

  @Override
  public Long getReads() {
    return reads;
  }

  @Override
  public Long queryReads() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.READS);
    return reads;
  }

  @Override
  public Long getReadBytes() {
    return readBytes;
  }

  @Override
  public Long queryReadBytes() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.READ_BYTES);
    return readBytes;
  }

  @Override
  public Long getWrites() {
    return writes;
  }

  @Override
  public Long queryWrites() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.WRITES);
    return writes;
  }

  @Override
  public Long getWriteBytes() {
    return writeBytes;
  }

  @Override
  public Long queryWriteBytes() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.WRITE_BYTES);
    return writeBytes;
  }

  @Override
  public Long getQueueLength() {
    return queueLength;
  }

  @Override
  public Long queryQueueLength() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.QUEUE_LENGTH);
    return queueLength;
  }

  @Override
  public Long getTransferTime() {
    return transferTime;
  }

  @Override
  public Long queryTransferTime() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.TRANSFER_TIME);
    return transferTime;
  }

  @Override
  public String getModelFamily() {
    return modelFamily;
  }

  @Override
  public String queryModelFamily() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.MODEL_FAMILY);
    return modelFamily;
  }

  @Override
  public String getFirmwareVersion() {
    return firmwareVersion;
  }

  @Override
  public String queryFirmwareVersion() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.FIRMWARE_VERSION);
    return firmwareVersion;
  }

  @Override
  public Long getRotationRate() {
    return rotationRate;
  }

  @Override
  public Long queryRotationRate() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.ROTATION_RATE);
    return rotationRate;
  }

  @Override
  public Long getReadErrorRate() {
    return readErrorRate;
  }

  @Override
  public Long queryReadErrorRate() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.READ_ERROR_RATE);
    return readErrorRate;
  }

  @Override
  public Long getSpinUpTime() {
    return spinUpTime;
  }

  @Override
  public Long querySpinUpTime() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.SPIN_UP_TIME);
    return spinUpTime;
  }

  @Override
  public Long getStartStopCycles() {
    return startStopCycles;
  }

  @Override
  public Long queryStartStopCycles() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.START_STOP_CYCLES);
    return startStopCycles;
  }

  @Override
  public Long getReallocatedSectors() {
    return reallocatedSectors;
  }

  @Override
  public Long queryReallocatedSectors() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.REALLOCATED_SECTORS);
    return reallocatedSectors;
  }

  @Override
  public Long getSeekErrorRate() {
    return seekErrorRate;
  }

  @Override
  public Long querySeekErrorRate() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.SEEK_ERROR_RATE);
    return seekErrorRate;
  }

  @Override
  public Long getPowerOnTime() {
    return powerOnTime;
  }

  @Override
  public Long queryPowerOnTime() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.POWER_ON_TIME);
    return powerOnTime;
  }

  @Override
  public Long getSpinRetries() {
    return spinRetries;
  }

  @Override
  public Long querySpinRetries() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.SPIN_RETRIES);
    return spinRetries;
  }

  @Override
  public Long getCalibrationRetries() {
    return calibrationRetries;
  }

  @Override
  public Long queryCalibrationRetries() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.CALIBRATION_RETRIES);
    return calibrationRetries;
  }

  @Override
  public Long getPowerCycles() {
    return powerCycles;
  }

  @Override
  public Long queryPowerCycles() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.POWER_CYCLES);
    return powerCycles;
  }

  @Override
  public Long getPoweroffRetracts() {
    return poweroffRetracts;
  }

  @Override
  public Long queryPoweroffRetracts() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.POWEROFF_RETRACTS);
    return poweroffRetracts;
  }

  @Override
  public Long getLoadCycles() {
    return loadCycles;
  }

  @Override
  public Long queryLoadCycles() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.LOAD_CYCLES);
    return loadCycles;
  }

  @Override
  public Long getTemperature() {
    return temperature;
  }

  @Override
  public Long queryTemperature() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.TEMPERATURE);
    return temperature;
  }

  @Override
  public Long getReallocatedEvents() {
    return reallocatedEvents;
  }

  @Override
  public Long queryReallocatedEvents() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.REALLOCATED_EVENTS);
    return reallocatedEvents;
  }

  @Override
  public Long getCurrentPendingSector() {
    return currentPendingSector;
  }

  @Override
  public Long queryCurrentPendingSector() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.CURRENT_PENDING_SECTOR);
    return currentPendingSector;
  }

  @Override
  public Long getOfflineUncorrectable() {
    return offlineUncorrectable;
  }

  @Override
  public Long queryOfflineUncorrectable() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.OFFLINE_UNCORRECTABLE);
    return offlineUncorrectable;
  }

  @Override
  public Long getCrcErrors() {
    return crcErrors;
  }

  @Override
  public Long queryCrcErrors() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.CRC_ERRORS);
    return crcErrors;
  }

  @Override
  public Long getMultizoneErrorRate() {
    return multizoneErrorRate;
  }

  @Override
  public Long queryMultizoneErrorRate() {
    if (driver == null) {
      throw new DetachedContainerException();
    }
    driver.query(DiskAttribute.MULTIZONE_ERROR_RATE);
    return multizoneErrorRate;
  }

  public void attach(ComponentDriver driver) {
    this.driver = driver;
    // Query all constant attributes:
    driver.query(DiskAttribute.NAME);
    driver.query(DiskAttribute.MODEL);
    driver.query(DiskAttribute.SERIAL);
  }
}
